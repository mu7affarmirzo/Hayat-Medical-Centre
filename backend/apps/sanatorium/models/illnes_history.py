import osfrom datetime import datetimeimport uuidfrom datetime import timedeltafrom django.db import models, transactionfrom django.db.models.signals import post_savefrom django.dispatch import receiverfrom apps.account.models import Account, MedicalService, DoctorAccountModel, NurseAccountModelfrom apps.account.models import PatientModelfrom apps.lis.models import LabResearchModel, upload_locationfrom apps.logus.models import ServiceModel, BookingModelfrom apps.sanatorium.models.diagnosis_template import DiagnosisTemplatefrom apps.warehouse.models import ItemsModel, ItemsInStockModelclass ProfessionsModel(models.Model):    name = models.CharField(max_length=50, blank=True, null=True)    def __str__(self):        return self.nameclass ToxicFactorsModel(models.Model):    name = models.CharField(max_length=50, blank=True, null=True)    def __str__(self):        return self.nameclass TagsModel(models.Model):    name = models.CharField(max_length=50, blank=True, null=True)    def __str__(self):        return self.nameclass IllnessHistory(models.Model):    TYPES = (        ('stationary', 'stationary'),        ('ambulatory', 'ambulatory'),    )    STATE = (        ('open', 'open'),        ('closed', 'closed'),    )    series_number = models.CharField(max_length=255, default=uuid.uuid4)    patient = models.ForeignKey(PatientModel, on_delete=models.CASCADE)    booking = models.ForeignKey(BookingModel, on_delete=models.CASCADE, related_name='illness_history')    type = models.CharField(choices=TYPES, max_length=15, default='stationary')    profession = models.ForeignKey(ProfessionsModel, on_delete=models.SET_NULL, null=True, blank=True)    toxic_factors = models.ManyToManyField(ToxicFactorsModel)    tags = models.ForeignKey(TagsModel, on_delete=models.SET_NULL, null=True, blank=True)    state = models.CharField(choices=STATE, default="open", max_length=100)    initial_diagnosis = models.ForeignKey(DiagnosisTemplate, on_delete=models.CASCADE, null=True, blank=True, related_name='initial')    at_arrival_diagnosis = models.ForeignKey(DiagnosisTemplate, on_delete=models.CASCADE, null=True, blank=True, related_name='arrival')    diagnosis = models.ForeignKey(DiagnosisTemplate, on_delete=models.CASCADE, null=True, blank=True, related_name='illness_history_diagnosis')    nurse = models.ManyToManyField(NurseAccountModel, related_name="illness_history_nurse")    doctor = models.ForeignKey(DoctorAccountModel, on_delete=models.CASCADE, related_name="illness_history_doctor", null=True, blank=True)    def __str__(self):        return str(self.series_number)class BaseMedicalServiceModel(models.Model):    STATE_CHOICES = (        ('assigned', 'assigned'),        ('cancelled', 'cancelled'),        ('stopped', 'stopped'),        ('dispatched', 'dispatched'),    )    illness_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE, null=True, blank=True)    medical_service = models.ForeignKey(MedicalService, on_delete=models.SET_NULL, null=True)    price = models.BigIntegerField(default=0)    consulted_doctor = models.ForeignKey(DoctorAccountModel, blank=True, null=True, on_delete=models.SET_NULL,                                         related_name='base_md_consulted_doctor')    state = models.CharField(choices=STATE_CHOICES, default='assigned', max_length=50)    created_by = models.ForeignKey(Account, related_name='b_md_created', on_delete=models.SET_NULL, null=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="modf_b_md", on_delete=models.SET_NULL, null=True)class BaseProcedureServiceModel(models.Model):    STATE_CHOICES = (        ('assigned', 'assigned'),        ('cancelled', 'cancelled'),        ('stopped', 'stopped'),        ('dispatched', 'dispatched'),    )    FREQUENCY_CHOICES = (        ("каждый день", "каждый день"),        ("через день", "через день"),    )    illness_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE, null=True, blank=True)    medical_service = models.ForeignKey(MedicalService, on_delete=models.SET_NULL, null=True)    price = models.BigIntegerField(default=0)    procedure_doctor = models.ForeignKey(DoctorAccountModel, blank=True, null=True, on_delete=models.SET_NULL,                                         related_name='base_procedure_doctor')    state = models.CharField(choices=STATE_CHOICES, default='assigned', max_length=50)    quantity = models.IntegerField(default=1)    done_quantity = models.IntegerField(default=0, null=True)    start_date = models.DateField(null=True)    frequency = models.CharField(choices=FREQUENCY_CHOICES, default='каждый день', max_length=50)    comments = models.TextField(null=True, blank=True)    created_by = models.ForeignKey(Account, related_name='bp_created', on_delete=models.SET_NULL, null=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="modf_bp", on_delete=models.SET_NULL, null=True)    def __str__(self):        return f"{self.illness_history.series_number} - {self.medical_service.name}"    @property    def progres_percentile(self):        return int(self.done_quantity / self.quantity*100)    @property    def remaining_quantity(self):        return int(self.quantity - self.done_quantity)    def save(self, *args, **kwargs):        # Get the original state before saving the object.        original_state = None        if self.pk:            original_state = BaseProcedureServiceModel.objects.get(pk=self.pk).state        super().save(*args, **kwargs)        # Check if the state has changed to 'dispatched' and create procedure days if it has.        if self.state == 'dispatched' and original_state != 'dispatched':            self.create_procedure_days()    def create_procedure_days(self):        """        Creates ProcedureDaysModel instances based on the quantity and frequency of the base procedure.        """        if not self.start_date or self.quantity <= 0:            return        for day_index in range(self.quantity):            procedure_start_at = self._get_procedure_start_time(self.start_date, day_index)            is_out_of_graphic = self._is_out_of_graphic(procedure_start_at)            ProcedureDaysModel.objects.create(                procedure=self,                start_at=procedure_start_at,                state='создано',                created_by=self.created_by,                is_out_of_graphic=is_out_of_graphic            )    def _get_procedure_start_time(self, start_date: datetime.date, day_offset: int) -> datetime:        """        Returns the start time of the procedure at 9:00 a.m. for the given day offset.        """        start_datetime = datetime.combine(start_date, datetime.min.time()) + timedelta(days=day_offset)        return start_datetime.replace(hour=9, minute=0)    def _is_out_of_graphic(self, start_at: datetime) -> bool:        """        Determines if the given start date is out of the booking end date.        """        return start_at.date() > self.illness_history.booking.end_dateclass ProcedureDaysModel(models.Model):    STATE_CHOICES = (        ('создано', 'создано'),        ('отменено', 'отменено'),        ('приостановлено', 'приостановлено'),        ('диспетчеризирован', 'диспетчеризирован'),        ('выполнено', 'выполнено'),    )    state = models.CharField(choices=STATE_CHOICES, default='created', max_length=50)    procedure = models.ForeignKey(BaseProcedureServiceModel, on_delete=models.CASCADE, null=True, blank=True, related_name='days')    start_at = models.DateTimeField(null=True, blank=True)    procedure_doctor = models.ForeignKey(DoctorAccountModel, on_delete=models.SET_NULL, null=True, blank=True)    comments = models.TextField(null=True, blank=True)    is_out_of_graphic = models.BooleanField(default=False, null=True, blank=True)    created_by = models.ForeignKey(Account, related_name='proc_days_created', on_delete=models.SET_NULL, null=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="proc_days_mod", on_delete=models.SET_NULL, null=True)    def save(self, *args, **kwargs):        # Get the original state before saving the object.        original_state = None        if self.pk:            original_state = ProcedureDaysModel.objects.get(pk=self.pk).state        super().save(*args, **kwargs)        # Increment or decrement the done_quantity of the procedure based on the state change.        if self.state == 'выполнено' and original_state != 'выполнено':            self.procedure.done_quantity += 1        elif original_state == 'выполнено' and self.state != 'выполнено':            self.procedure.done_quantity -= 1        # Persist the done_quantity change to the procedure.        self.procedure.save()class BaseLabResearchServiceModel(models.Model):    STATE_CHOICES = (        ('assigned', 'assigned'),        ('cancelled', 'cancelled'),        ('stopped', 'stopped'),        ('dispatched', 'dispatched'),        ('results', 'results'),    )    illness_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE, null=True,                                        related_name='base_lab_research')    lab = models.ForeignKey(LabResearchModel, on_delete=models.SET_NULL, null=True, related_name="lab_app")    price = models.BigIntegerField(default=0)    lab_doctor = models.ForeignKey(DoctorAccountModel, blank=True, null=True, on_delete=models.SET_NULL,                                   related_name='base_lab_doctor')    state = models.CharField(choices=STATE_CHOICES, default='assigned', max_length=50)    start_date = models.DateField(null=True)    comments = models.TextField(null=True, blank=True)    created_by = models.ForeignKey(Account, related_name='bl_created', on_delete=models.SET_NULL, null=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="modf_bl", on_delete=models.SET_NULL, null=True)class LabResult(models.Model):    base_lab_research = models.ForeignKey(BaseLabResearchServiceModel, related_name='lab_results', on_delete=models.CASCADE, null=True, blank=True)    comments = models.TextField(null=True, blank=True)    result_date = models.DateTimeField(auto_now_add=True)    attached_file = models.FileField(upload_to=upload_location, null=True, blank=True)    file_format = models.CharField(max_length=10, null=True, blank=True)    created_by = models.ForeignKey(Account, related_name='lab_result_created', on_delete=models.SET_NULL, null=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="lab_result_mdf", on_delete=models.SET_NULL, null=True)    class Meta:        ordering = ['-created_at']  # Most recent results first    def save(self, *args, **kwargs):        # Check if a file is uploaded or updated        if self.attached_file and self.attached_file.name:            # Extract file extension as format            self.file_format = os.path.splitext(self.attached_file.name)[-1].replace('.', '').lower()        super().save(*args, **kwargs)    def __str__(self):        return f"Lab result for {self.base_lab_research} on {self.result_date}"class BasePillsInjectionsModel(models.Model):    STATE_CHOICES = (        ('assigned', 'assigned'),        ('cancelled', 'cancelled'),        ('stopped', 'stopped'),        ('dispatched', 'dispatched'),    )    PILLS_FREQUENCY_CHOICES = (        ("3 раза в день", 3),        ("до еды", 1),        ("после еды", 1),    )    illness_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE,                                        null=True, related_name='base_pills_injections')    state = models.CharField(choices=STATE_CHOICES, default='assigned', max_length=50)    quantity_per_session = models.IntegerField(default=1)    period_days = models.IntegerField(null=True, blank=True)    start_date = models.DateField(null=True)    end_date = models.DateField(null=True)    frequency = models.CharField(choices=PILLS_FREQUENCY_CHOICES, default='', max_length=50)    comments = models.TextField(null=True, blank=True)    instruction = models.TextField(null=True, blank=True)    created_by = models.ForeignKey(Account, related_name='b_pl_created', on_delete=models.SET_NULL, null=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="modf_b_pl", on_delete=models.SET_NULL, null=True)    def __str__(self):        return f"{self.illness_history} - {self.pills_injections}"    # def save(self, *args, **kwargs):    #     if self.pk:    #         # The instance already exists, so it's an update    #         previous_instance = BasePillsInjectionsModel.objects.get(pk=self.pk)    #         previous_quantity = previous_instance.quantity_per_session * previous_instance.period_days    #         quantity_difference = self.quantity - previous_instance.quantity    #     else:    #         # The instance is new, so it's a creation    #         quantity_difference = self.quantity    #    #     # Update the quantity of the item in stock    #     if self.pills_injections:    #         self.pills_injections.unit_quantity -= quantity_difference    #         self.price = self.pills_injections.unit_price    #         self.pills_injections.save()    #    #     elif self.state in ['cancelled', 'stopped'] and self.cheque:    #         # Delete related cheque item if the state is cancelled or stopped    #         self.cheque.cheque_items.filter(item=self.pills_injections).delete()    #    #     super().save(*args, **kwargs)class PatientDietModel(models.Model):    TYPES = (        ('regular_diet', 'regular_diet'),        ('exception', 'exception'),        ('allergy', 'allergy'),    )    patient = models.ForeignKey(PatientModel, on_delete=models.CASCADE)    illness_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE)    food = models.CharField(max_length=150, null=True)    type = models.CharField(choices=TYPES, max_length=15, default='regular_diet')    comment = models.TextField(null=True, blank=True)    start_date = models.DateField()    end_date = models.DateField()    def __str__(self):        return str(self.patient.full_name)class ComplaintModel(models.Model):    name = models.CharField(max_length=500)class SummaryModel(models.Model):    name = models.CharField(max_length=255)class ConsultingAndResearchModel(models.Model):    name = models.CharField(max_length=255)class PivotConsultingAndResearchModel(models.Model):    ill_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE, null=True, blank=True)    consulting = models.ForeignKey(ConsultingAndResearchModel, on_delete=models.SET_NULL, null=True, blank=True)    # updated_by    # created_byclass TreatmentServiceModel(models.Model):    ill_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE, null=True, blank=True)    service = models.ForeignKey(ServiceModel, on_delete=models.SET_NULL, null=True, blank=True)    # days    # quantityclass PivotPillsDrugsModel(models.Model):    ill_history = models.ForeignKey(IllnessHistory, on_delete=models.CASCADE, null=True, blank=True)    pills = models.ForeignKey(ItemsModel, on_delete=models.SET_NULL, null=True, blank=True)    quantity = models.IntegerField()    # days    # doseclass AppWithDutyDocktor(models.Model):    complaint = models.ManyToManyField(ComplaintModel, related_name="apps_with_duty_doc",)# on_delete=models.CASCADE)    obj_data = models.ManyToManyField(ComplaintModel, related_name="apps_with_duty_doc_data",)# on_delete=models.CASCADE)    temperature = models.FloatField(default=36.6)    arterial = models.CharField(max_length=10)    heart_beat = models.IntegerField()    diagnosis = models.ForeignKey(DiagnosisTemplate, on_delete=models.CASCADE)    summary = models.ForeignKey(SummaryModel, on_delete=models.CASCADE)class ProcedureTasksModel(models.Model):    STATE_CHOICES = (        ('dispatched', 'dispatched'),        ('cancelled', 'cancelled'),        ('paused', 'paused'),        ('done', 'done'),    )    state = models.CharField(max_length=25, null=True, default='dispatched', blank=True)    procedure = models.ForeignKey(BaseProcedureServiceModel, on_delete=models.CASCADE, null=True, blank=True)    procedure_doctor = models.ForeignKey(DoctorAccountModel, on_delete=models.SET_NULL, null=True, blank=True)    start_at = models.DateTimeField(null=True, blank=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="modf_proc_tasks", on_delete=models.SET_NULL, null=True)@receiver(post_save, sender=BaseProcedureServiceModel)def notify_staff_on_pills_number(sender, instance: BaseProcedureServiceModel=None, created=False, **kwargs):    if created:        nurses = instance.illness_history.nurse.all()        nurses_usernames = ', '.join([f'@{nurse.nurse.tg_username}' for nurse in nurses if nurse.nurse.tg_username])        msg = (f"---------------------------------\n"               f"|   TEST NOTIFICATIONS   \n"               f"---------------------------------\n\n\n"               f"🏥<b>Палата:</b> {instance.illness_history.booking.current_room.room_number}\n"               f"🩺<b>Процедура:</b> {instance.medical_service}\n"               f"⏰<b>Кратность:</b> {instance.frequency}\n"               f"⚠<b>Особые указаниe:</b> {instance.comments}\n"               f"👨‍⚕️<b>Назначил:</b> {instance.created_by.full_name} @{instance.created_by.tg_username}\n\n"               f"🚀<b>Ожидается содействие от(медсестры):</b> {nurses_usernames}")        # notify(msg, 'procedures')@receiver(post_save, sender=IllnessHistory)def create_warehouse_cheque_number(sender, instance=None, created=False, **kwargs):    if created:        from apps.warehouse.models import WarehouseChequeModel        WarehouseChequeModel.objects.create(            is_sanatorium_based=True,            patient=instance.patient,            illness_history=instance        )