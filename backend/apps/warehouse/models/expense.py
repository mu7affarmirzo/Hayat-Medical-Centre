from decouple import configfrom django.db import modelsfrom django.db.models.signals import post_save, pre_savefrom django.dispatch import receiverfrom django.urls import reversefrom apps.account.models import Account, BranchModel, NotificationModelfrom apps.warehouse.models import ItemsModel, StorePointModel, ItemsInStockModelfrom apps.warehouse.models.store_point import StorePointStaffModelHOST = config('PRODUCTION_HOST')class ExpenseModel(models.Model):    STATE_CHOICES = (        ('в ожидании', 'в ожидании'),        ('доставлено', 'доставлено'),        ('отказоно', 'отказоно'),    )    series = models.CharField(null=True, blank=True, max_length=255)    receiver = models.ForeignKey(Account, on_delete=models.SET_NULL, null=True, related_name="expenses")    created_by = models.ForeignKey(Account, related_name="w_expense_creates", on_delete=models.SET_NULL,                                   null=True)    store_point = models.ForeignKey(StorePointModel, on_delete=models.SET_NULL, null=True, blank=True)    state = models.CharField(choices=STATE_CHOICES, default='в ожидании', max_length=50)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="w_expense_mod", on_delete=models.SET_NULL, null=True)class ExpenseItemsModel(models.Model):    STATE_CHOICES = (        ('в ожидании', 'в ожидании'),        ('отменена', 'отменена'),        ('не найдено', 'не найдено'),        ('принято', 'принято'),    )    item = models.ForeignKey(ItemsInStockModel, on_delete=models.CASCADE, related_name='expanse_items')    expense = models.ForeignKey(ExpenseModel, on_delete=models.CASCADE, related_name='expanse_items')    quantity = models.IntegerField(default=1)    state = models.CharField(choices=STATE_CHOICES, default='принято', max_length=50)    created_by = models.ForeignKey(Account, related_name="w_expense_items_creates", on_delete=models.SET_NULL, null=True)    created_at = models.DateTimeField(auto_now_add=True)    modified_at = models.DateTimeField(auto_now=True)    modified_by = models.ForeignKey(Account, related_name="w_expense_items_mod", on_delete=models.SET_NULL, null=True)    @property    def expense_price(self):        return self.item.unit_price * self.quantity    def save(self, *args, **kwargs):        if self.pk:            # The instance already exists, so it's an update            previous_instance = ExpenseItemsModel.objects.get(pk=self.pk)            quantity_difference = self.quantity - previous_instance.quantity        else:            # The instance is new, so it's a creation            quantity_difference = self.quantity        # Update the quantity of the item in stock        if self.item:            self.item.unit_quantity -= quantity_difference            self.item.save()        super().save(*args, **kwargs)@receiver(post_save, sender=ExpenseModel)def create_notification_to_receiver(sender, instance: ExpenseModel = None, created=False, **kwargs):    if created:        receiver = instance.receiver        target_receivers = StorePointStaffModel.objects.filter(            store_point=receiver        )        for user in target_receivers:            url = reverse('warehouse_v2:expanses-detailed', args=[instance.id])            NotificationModel.objects.create(                sender=instance.created_by,                receiver=user.staff,                message='Вам отправили новый <<Расход>>!',                generated_url=url            )